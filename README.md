# CE493 Project: Eyeriss-Style CNN Accelerator

## üìú Description

This project is an implementation of a single convolutional layer accelerator, inspired by the Eyeriss architecture, for CE493.

The dataset we elected to use for testing was MNIST. We followed a complete hardware verification flow, starting from high-level software models down to hardware simulation:

1. **Floating-Point Model:** First, we trained a standard floating-point CNN in PyTorch on the MNIST dataset (`model_fp.py`). The purpose of this was to generate a realistic, trained set of weights (`mnist_cnn.pth`).

2. **Bit-Accurate Golden Model:** We then developed a script to convert the floating point weights to fixed point (`model_q.py`), as well as a golden reference model using those weights (`model_golden.py`). This model loads the quantized weights and emulates the exact bit-accurate hardware datapath to produce a "perfect" output file.

3. **RTL & Testbench Development:** Finally, we designed the accelerator RTL in Verilog. We also developed a Verilog testbench that reads the stimulus files (inputs and weights) and the golden_output.hex file generated by our Python scripts. This testbench feeds the RTL and automatically compares its output, bit-for-bit, against the golden model to verify hardware correctness.

-----
Here's the updated "Verification Flow" section with the exact commands.

-----

## üîÅ Verification Flow

This project's verification flow is sequential. Run the following commands in order from your terminal.

### 1\. Train the Floating-Point Model

```sh
python model_fp.py
```
### 2\. Quantize Data
```sh
python model_q.py
```

### 3\. Run the Bit-Accurate Golden Model
```sh
python model_golden.py
```

### 4\. Generate RTL Stimulus Files

This final script converts all `.npy` data files into 16-bit 2's complement hexadecimal text files for Verilog.

```sh
python save_to_hex.py
```

### 5\. Run RTL Simulation

-----

## ‚öôÔ∏è Hardware Datapath Specification

The golden model and RTL are designed to match this fixed-point specification:

  * **Data Format:** 16-bit Fixed-Point (**Q2.14**)
      * 1 Sign Bit
      * 1 Integer Bit
      * 14 Fractional Bits
      * *Real-World Range:* `[-2.0 to +1.999...]`
  * **Accumulator Width:** 40-bit Signed
      * This prevents overflow during the multiply-accumulate (MAC) operations for a single output pixel.

-----
